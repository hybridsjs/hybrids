# Layout Engine

The layout engine provides CSS layout rules directly in templates without external dependencies. It's built in a similar way to utility-first CSS frameworks, but with much more powerful features.

It focuses only on "invisible" CSS rules, like display types, alignments, positioning, sizing, etc. The rest should be defined inside of the reusable UI components by [styling](/component-model/templates.md#styling) methods supported by the templates.

## Usage

Add `<template layout></template>` element wrapper with at least one empty `layout` attribute to the root template of the component. The `<template>` element represents the host element, which also can be styled:

```js
define({
  tag: "my-element",
  render: () => html`
    <template layout="row">
      <div layout="grow"></div>
    </template>
  `
});
```

While the template compiles, a group of attributes (`layout*="..."`) containing the layout rules resolve to a single unique class selector added to the element. Generated selectors are shared between all of the component instances (regardless if the Shadow DOM is used or not). If the browser supports Constructable Stylesheets, the generated CSS is added to the global single shared stylesheet, which makes the styling the fastest possible.

### Other Styles

When using layout engine inside of the UI components, you can still mix the approach with other styling technics. Styles generated by the template helpers are added after the layout engine styles:

```js
define({
  tag: "my-button",
  render: () => html`
    <template layout="grid">
      <button><slot></slot></button>
    </template>
  `.css`
    button {
      ...
    }
  `,
});
```

## Compound Selectors

```html
<div layout.selector=""></div>
```

The `layout` attribute name can be extended with any correct CSS selector, which does not contain space character.

The value of the attribute does not support expressions, as the compilation process takes place before the function runs for the first time with arguments. However, the selector is added to the generated class selector, so the rules will apply only if the conditions are met.

```js
define({
  tag: "my-element",
  disabled: false,
  render: ({ disabled }) => html`
    <template layout="row">
      <!-- attribute selector -->
      <my-button
        disabled="${disabled}"
        layout="fixed top right"
        layout[disabled]="hidden"
      ></my-button>
      <!-- class selector -->
      <my-other-element
        class="${ { show: disabled } }"
        layout="hidden"
        layout.show="block">
      </my-other-element>
    </template>
  `
});
```

Any supported CSS selector can be used, like pseudo-classes, etc:

```html
<div layout:first-child="margin:0"></div>
<div layout:last-of-type="grow"></div>
```

## Media Queries

```html
<div layout="row gap" layout@768px="column gap:2"></div>
```

The media queries are supported by the part followed by `@` character. For the convenience, the engine defaults to `min-width` media query feature. Engine supports the following values:

* `portrait` - `@media (orientation: portrait)`
* `landscape` - `@media (orientation: landscape)`
* `hover` - `@media (hover: hover)`
* `any-hover` - `@media (any-hover: hover)`
* `print` - `@media print`
* `[value]` - `@media (min-width: [value])`

```html
<div layout="row" layout@portrait="column gap:2" layout@landscape="row gap:3"></div>
```

For more complex queries, use `|` character to create `AND` condition, and `:` to create `OR` condition:

```html
<div layout="row" layout@landscape|768px:1024px="column gap:2"></div>
```

The above example generates the following complex media query:

```css
@media (orientation: landscape) and (min-width: 768px), (min-width: 1024px) { ... }
```

## Arguments

The attribute value contains a space-separated list of rules. The rules are applied in the order they appear in the attribute. The rules come with useful predefined arguments, but depending on the rule, they can take a list of arguments separated by `:` character (without the whitespace):

```html
<div layout="column gap:3 items:center width:full:100px"></div>
```

If the rule supports more than one argument, you can skip it by omitting the value. For instance, you can use:

```html
<div layout="row::inline width::50%"></div>
```

### Dimensions

If the argument type is dimension, the engine maps it with the following order:

1. Predefined strings maps to corresponding values:
   * `min` -> `min-content`
   * `max` -> `max-content`
   * `fit` -> `fit-content`
   * `full` -> `100%`
2. A number without the type suffix maps to the multiplication of `8px`:
   * `0` -> `0px`
   * `0.5` -> `4px`
   * `1` -> `8px`
   * `2` -> `16px`
   * `3` -> `24px`
   * ...
3. Provided value is used as is.

## CSS Variables

Add `--` prefix to use a CSS variable as an argument. The engine will pass it as is, without processing, so the variable can represents dynamic value, which can be updated in runtime, or scoped to some subtree.

```html
<div layout="margin:--layout-spacing"></div>
```

## Rules

The following rules are supported by the engine:

### Base

| Rule     | Arguments     | Defaults | Properties                                                               |
|----------|---------------|----------|--------------------------------------------------------------------------|
| block    | [align:value] | block    | `display: block`<br>`text-align: [align]`                                |
| inline   | ---           | ---      | `display: inline`<br>`display: [type]-inline`                            |
| contents | ---           | ---      | `display: contents`                                                      |
| hidden   | ---           | ---      | `display: none`                                                          |

The `inline` rule can be used after other display types to make the element inline with corresponding type:

```html
<div layout="block inline"></div>
<div layout="row inline"></div>
<div layout="grid:... inline"></div>
```

### Flexbox

| Rule                                           | Arguments                | Defaults      | Properties                                   |
|------------------------------------------------|--------------------------|---------------|----------------------------------------------|
| row<br>row-reverse<br>column<br>column-reverse | [wrap:value]             | [type]:nowrap | `display: flex`<br>`flex-flow: type [wrap]`  |
| grow                                           | [number:value]           | grow:1        | `flex-grow: [number]`                        |
| shrink                                         | [number:value]           | shrink:1      | `flex-shrink: [number]`                      |
| basis                                          | [size:dimension]         | ---           | `flex-basis: [size]`                         |
| gap                                            | [column:dim.]:[row:dim.] | gap:1         | `column-gap: [column];`<br>`row-gap: [row];` |
| order                                          | [number:value]           | order:0       | `order: [number]`                            |

### Grid

| Rule  | Arguments                                 | Defaults | Properties                                                                                                                    |
|-------|-------------------------------------------|----------|-------------------------------------------------------------------------------------------------------------------------------|
| grid  | [columns]:[rows]:[autoFlow:value]:[dense] | grid:1   | `display: grid`<br>`grid-template-columns: [columns]`<br>`grid-template-rows: [rows]`<br>`grid-auto-flow: [autoFlow] [dense]` |
| area  | [column:value]:[row:value]                | none     | `grid-column: span [number] \| [value]`<br>`grid-row: span [number] \| [value]`                                               |
| gap   | [column:dimension]:[row:dimension]        | gap:1    | `column-gap: [column];`<br>`row-gap: [row];`                                                                                  |
| order | [number:value]                            | order:0  | `order: [number];`                                                                                                            |

CSS Grid layout is very flexible, but to make it easier to use, the engine maps `[columns]` and `[rows]` arguments with the following rules:

* A number without the type suffix maps to `repeat([number], min(0, 1fr))`
* Otherwise, the value follows [dimension](#dimensions) type
* Multiple rows/columns should be split with `|` character, ex.: `grid:1|min`
* Complex rules should not use whitespace, eg.: `grid:repeat(2,minmax(50%,1fr)`

Use following examples as a reference:

* `grid:12` - `repeat(12, minmax(0, 1fr)))`
* `grid:2|min|2` -> `repeat(2, minmax(0, 1fr) min-content repeat(2, minmax(0, 1fr)));`
* `grid:2:100px|max` -> columns: `repeat(2, minmax(0, 1fr)))`, rows: `100px max-content`

### Alignment

| Rule    | Arguments                    | Defaults      | Properties                                       |
|---------|------------------------------|---------------|--------------------------------------------------|
| items   | [align:value][justify:value] | items:start   | `place-items: [align] [justify]`                 |
| content | [align:value][justify:value] | content:start | `place-content: [align] [justify]`               |
| self    | [align:value][justify:value] | self:start    | `place-self: [align] [justify]`                  |
| center  | ---                          | ---           | `place-items: center`<br>`place-content: center` |

### Size

| Rule     | Arguments                                                              | Defaults                    | Properties                                                                                                                                                         |
|----------|------------------------------------------------------------------------|-----------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| size     | [width:dimension]:[height:dimension]                                   | ---                         | `width: [width]`<br>`height: [height] \|\| [width]`<br>`box-sizing: border-box`              |
| width    | [base:dim.]:[min:dim.]:[max:dim.]                                      | ---                         | `width: [base]`<br>`min-width: [min]`<br>`max-width: [max]`<br>`box-sizing: border-box`      |
| height   | [base:dim.]:[min:dim.]:[max:dim.]                                      | ---                         | `height: [base]`<br>`min-height: [min]`<br>`max-height: [max]`<br>`box-sizing: border-box`   |
| ratio    | [value]                                                                | ---                         | `aspect-ratio: [value]`                                                                      |
| overflow | [type:value]<br>[axis:value]:[type:value]                              | overflow:hidden             | `overflow: [type]`<br>`overflow-[axis]: [type]`<br>When `scroll` also:<br>`flex: 1 1 0`<br>`overscroll-behavior: contain`<br>`--webkit-overflow-scrolling: touch`  |
| margin   | [v1:dim.]:[v2:dim.]:[v3:dim.]:[v4:dim.]<br>[side:value]:[v:dimension] | margin:1<br>margin:[side]:1 | `margin: [v1] [v2] [v3] [v4]`<br>`margin-[side]: [v]`                                         |
| padding  | [v1:dim.]:[v2:dim.]:[v3:dim.]:[v4:dim.]<br>[side:value]:[v:dimension] | padding:1<br>padding:[side]:1 | `padding: [v1] [v2] [v3] [v4]`<br>`padding-[side]: [v]`                                     |

### Position

#### Types

| Rule     | Properties           |
|----------|----------------------|
| absolute | `position: absolute` |
| relative | `position: relative` |
| fixed    | `position: fixed`    |
| sticky   | `position: sticky`   |
| static   | `position: static`   |

#### Values

| Rule   | Arguments         | Defaults | Properties                       |
|--------|-------------------|----------|----------------------------------|
| inset  | [value:dimension] | inset:0  | `top,right,bottom,left: [value]` |
| top    | [value:dimension] | top:0    | `top: [value]`                   |
| right  | [value:dimension] | right:0  | `right: [value]`                 |
| bottom | [value:dimension] | bottom:0 | `bottom: [value]`                |
| left   | [value:dimension] | left:0   | `left: [value]`                  |
| layer  | [index:value]     | layer:1  | `z-index: [index]`               |

### Transition API

| Rule | Arguments     | Defaults | Properties                     |
|------|---------------|----------|--------------------------------|
| view | [name:value]  | ---      | `view-transition-name: [name]` |

## Generic Values

You can extend ruleset by using special empty rule `::`. It generates a CSS property with a value set to CSS variable based on its name. In another words, it allows to use predefined design tokens, which points to any CSS properties.

| Rule   | Arguments                       | Properties                    |
|--------|--------------------------------|--------------------------------|
| ::     | [[prefix]:...]:[property]:[name] | `[property]: var(--[...args])` |

```html
<style>
  html {
    --color-primary: blue;
    /* ... */

    /* Prefixed variables */
    --ui-font-body: 18px / 20px sans-serif;
  }
</style>
```

```html
<div layout="block ::color:primary ::ui:font:body"></div>
```

The above example generates the following CSS:

```css
{
  display: block;
  color: var(--color-primary);
  font: var(--ui-font-body);
}
```
