# Layout Engine

!> The feature is unstable. It is unlikely, but some breaking changes may occur without the major version bump until `v8.2.0` release.

The layout engine provides creating CSS layouts in-place in templates without any external dependencies. It's built in similar way to utility-first CSS frameworks, but with much more powerful features.

It focuses on "invisible" CSS rules, like display types, alignments, positioning, sizing, etc. The rest should be defined inside of the reusable UI components by [styling](/component-model/templates.md#styling) supported by the templates.

## Usage

Add `<template layout></template>` element wrapper with at least one empty `layout` attribute to the root template of the component. The `<template>` element represents the host element, which also can be styled:

```js
define({
  tag: "my-element",
  render: () => html`
    <template layout="row">
      <div layout="grow"></div>
    </template>
  `
});
```

When the template is compiled, a group of attributes (`layout*="..."`) containing the layout rules compiles to single unique class selector added to the element. Generated selectors are shared between all of the component instances, regardless if the Shadow DOM is used or not. If the browser supports Constructable Stylesheets, the generated CSS is added to the global single shared stylesheet, which makes the styling the fastest possible.

### Targets

The feature supports both `content` and `render` properties of the component's definition. Styling `content` is especially useful for creating layouts in app views, which don't require Shadow DOM:

```js
define({
  tag: "my-app-view",
  content: () => html`
    <template layout="column">
      ...
    </template>
  `,
});
```

### Mixing

If it is required, or preferred to use layout engine inside of the UI components, you can mix the approach with other styling technics. Styles generated by template helpers are addded after the layout engine generated styles.

```js
define({
  tag: "my-button",
  render: () => html`
    <template layout="grid">
      <button><slot></slot></button>
    </template>
  `.css`
    button {
      ...
    }
  `,
});
```

### Compound Selectors

The `layout` attribute does not support expressions as the value, because the process takes place when the template is compiled (before it runs for the first time with arguments). However, the attribute can be extended with compound selector. The rules will apply only if the conditions are met:

```js
define({
  tag: "my-element",
  disabled: false,
  render: ({ disabled }) => html`
    <template layout="row">
      <!-- attribute selector -->
      <my-button
        disabled="${disabled}"
        layout="fixed top right"
        layout[disabled]="hidden"
      ></my-button>
      <!-- class selector -->
      <my-other-element
        class="${ { show: disabled } }"
        layout="hidden"
        layout.show="block">
      </my-other-element>
    </template>
  `
});
```

The compound selector is place as-is into the generated class selector, so any supported CSS selector can be used, like pseudo-classes, etc:

```html
<div layout:first-child="margin:0"></div>
<div layout:last-of-type="grow"></div>
```

### Media Queries

Similarly to the compound selector, the layout supports media queries with the value followed by `@` character. Generally, not predefined values maps to `min-width` media query (The layout engine comes with `portrait` and `landscape` built-in queries).

```html
<div layout="row gap" layout@768px="column gap:2"></div>
```

### Arguments

The attribute value contains space-separated list of rules. The rules are applied in the order they are added to the attribute. The rules comes with useful predefined arguments, but depending on the rule, they can take a list of arguments separated by `:` character (without the whitespace):

```html
<div layout="column gap:3 items:center width:full:100px"></div>
```

If the rule supports more than one argument, you can skip it by omitting the value:

```html
<div layout="row::inline width::50%"></div>
```

#### Dimensions

If the argument type is dimension, the engine maps it with the following order:

1. Predefined strings maps to corresponding values:
  * `min` -> `min-content`
  * `max` -> `max-content`
  * `fit` -> `fit-content`
  * `full` -> `100%`
2. A number without the type suffix maps to the multiplication of `8px`:
  * `0` -> `0px`
  * `0.5` -> `4px`
  * `1` -> `8px`
  * `2` -> `16px`
  * `3` -> `24px`
  * ...
3. Provided value is used as is.

#### CSS Variables

Add `--` prefix to use a CSS variable as an argument. The engine will pass it as is, without processing, so the variable can represents dynamic value, which can be updated in runtime, or scoped to some subtree.

```html
<div layout="margin:--layout-spacing"></div>
```

## Rules

### Base

| Rule   | Arguments     | Defaults | Properties                                    |
|--------|---------------|----------|-----------------------------------------------|
| block  | [align:value] | block    | `display: block`<br>`text-align: [align]`     |
| inline |               | ---      | `display: inline`<br>`display: [type]-inline` |
| hidden | ---           | ---      | `display: none`                               |

The `inline` rule can be used after other display types to make the element inline with corresponding type:

```html
<div layout="block inline"></div>
<div layout="row inline"></div>
<div layout="grid inline"></div>
```

### Flexbox

| Rule                                           | Arguments                | Defaults    | Properties                                                       |
|------------------------------------------------|--------------------------|-------------|------------------------------------------------------------------|
| row<br>row-reverse<br>column<br>column-reverse | [wrap:value]             | type:nowrap | `display: flex` <br>`flex-flow: type [wrap]`<br>`flex-shrink: 0` |
| grow                                           | [number:value]           | grow:1      | `flex-grow: [number]`                                            |
| shrink                                         | [number:value]           | shrink:1    | `flex-shrink: [number]`                                          |
| basis                                          | [size:dimension]         | ---         | `flex-basis: [size]`                                             |
| gap                                            | [column:dim.]:[row:dim.] | gap:1       | `column-gap: [column];`<br>`row-gap: [row];`                     |
| order                                          | [number:value]           | order:0     | `order: [number]`                                                |

### Grid

| Rule  | Arguments                                 | Defaults | Properties                                                                                                                    |
|-------|-------------------------------------------|----------|-------------------------------------------------------------------------------------------------------------------------------|
| grid  | [columns]:[rows]:[autoFlow:value]:[dense] | grid:1   | `display: grid`<br>`grid-template-columns: [columns]`<br>`grid-template-rows: [rows]`<br>`grid-auto-flow: [autoFlow] [dense]` |
| area  | [column:value]:[row:value]                | none     | `grid-column: span [number] \| [value]`<br>`grid-row: span [number] \| [value]`                                               |
| gap   | [column:dimension]:[row:dimension]        | gap:1    | `column-gap: [column];`<br>`row-gap: [row];`                                                                                  |
| order | [number:value]                            | order:0  | `order: [number];`                                                                                                            |

CSS Grid layout is very flexible, but to make it easier to use, the engine maps `[columns]` and `[rows]` arguments with the following rules:

* A number without the type suffix maps to `repeat([number], min(0, 1fr))`
* Otherwise, the value follows [dimension](#dimensions) type
* Multiple rows/columns should be split with `|` character, ex.: `grid:1|min`
* Complex rules should not use whitespace, eg.: `grid:repeat(2,minmax(50%,1fr)`

Use following examples as a reference:

* `grid:12` - `repeat(12, minmax(0, 1fr)))`
* `grid:2|min|2` -> `repeat(2, minmax(0, 1fr) min-content repeat(2, minmax(0, 1fr)));`
* `grid:2:100px|max` -> columns: `repeat(2, minmax(0, 1fr)))`, rows: `100px max-content`

### Alignment

| Rule    | Arguments                    | Defaults      | Properties                                       |
|---------|------------------------------|---------------|--------------------------------------------------|
| items   | [align:value][justify:value] | items:start   | `place-items: [align] [justify]`                 |
| content | [align:value][justify:value] | content:start | `place-content: [align] [justify]`               |
| self    | [align:value][justify:value] | self:start    | `place-self: [align] [justify]`                  |
| center  | ---                          | ---           | `place-items: center`<br>`place-content: center` |

### Size

| Rule     | Arguments                                                              | Defaults                    | Properties                                                                                                                                                         |
|----------|------------------------------------------------------------------------|-----------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| width    | [base:dimension]:[min:dimension]:[max:dimension]                       | ---                         | `width: [base]`<br>`min-width: [min]`<br>`max-width: [max]`                                                                                                        |
| height   | [base:dimension]:[min:dimension]:[max:dimension]                       | ---                         | `height: [base]`<br>`min-height: [min]`<br>`max-height: [max]`                                                                                                     |
| ratio    | [value]                                                                | ---                         | `aspect-ratio: [value]`                                                                                                                                            |
| overflow | [type:value]<br>[axis:value]:[type:value]                              | overflow:hidden             | `overflow: [type]`<br>`overflow-[axis]: [type]`<br>For `scroll` type:<br>`flex-basis: 0`<br>`overscroll-behavior: contain`<br>`--webkit-overflow-scrolling: touch` |
| margin   | [v1:dim.]:[v2:dim.]:[v3:dim.]:[v4:dim.]<br>[side:value]:[v1:dimension] | margin:1<br>margin:[side]:1 | `margin: [v1] [v2] [v3] [v4]`<br>`margin-[side]: [v1]`                                                                                                             |

### Position

#### Types

| Rule     | Properties           |
|----------|----------------------|
| absolute | `position: absolute` |
| relative | `position: relative` |
| fixed    | `position: fixed`    |
| sticky   | `position: sticky`   |
| static   | `position: static`   |

#### Values

| Rule   | Arguments         | Defaults | Properties                             |
|--------|-------------------|----------|----------------------------------------|
| inset  | ---               | ---      | `top: 0; right: 0; bottom: 0; left: 0` |
| top    | [value:dimension] | top:0    | `top: [value]`                         |
| right  | [value:dimension] | right:0  | `right: [value]`                       |
| bottom | [value:dimension] | bottom:0 | `bottom: [value]`                      |
| left   | [value:dimension] | left:0   | `left: [value]`                        |
| layer  | [index:value]     | layer:1  | `z-index: [index]`                     |